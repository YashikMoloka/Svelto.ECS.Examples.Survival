using System.Collections;
using Svelto.DataStructures;

namespace Svelto.ECS.Example.Survive.Characters.Enemies
{
    public class EnemyDeathEngine : IQueryingEntitiesEngine
    {
        public EnemyDeathEngine(IEntityFunctions entityFunctions, EnemyDeathSequencer enemyDeadSequencer)
        {
            _entityFunctions = entityFunctions;

            _enemyDeadSequencer = enemyDeadSequencer;
        }

        public IEntitiesDB entitiesDB { get; set; }

        public void Ready()
        {
            CheckIfDead().Run();
        }

        IEnumerator CheckIfDead()
        {
            var enemyIterationInfo = new FasterList<EnemyIterationInfo>();
            //this struct will allow use zero allocation lambdas. When c# 7 will be available in Unity
            //this will be less awkward thanks to the new local functions feature
            var valueTuple = new LambdaParameters {item1 = enemyIterationInfo};

            while (true)
            {
                //wait for enemies to be created
                while (entitiesDB.HasAny<EnemyEntityStruct>() == false) yield return null;

                //fetch the current EnemyEntityViewStruct array, avoid to do it inside the iteration
                //to be faster
                int count;
                valueTuple.item2 = entitiesDB.QueryEntities<EnemyEntityViewStruct>(out count);

                //iterate over the EnemyEntityStruct and use the healthEntityStruct that are generated by the
                //same entities. Use lambda without catching any external variable so that it won't allocate (which is
                //very important! this will be less awkward when c# 7 is out)
                entitiesDB.ExecuteOnEntities(ref valueTuple,
                                             (ref EnemyEntityStruct  enemyStruct,
                                              ref HealthEntityStruct healthEntityStruct,
                                              ref LambdaParameters   _parameters, int iterationIndex) =>
                                             {
                                                 if (healthEntityStruct.dead == false) return;

                                                 SetParametersForDeath(ref _parameters.item2[iterationIndex]);

                                                 _parameters.item1.Add(new EnemyIterationInfo(healthEntityStruct.ID,
                                                                                              (int) ECSGroups
                                                                                                 .EnemyDisabledGroups +
                                                                                              (int) enemyStruct
                                                                                                 .enemyType));
                                             });

                for (int i = 0; i < enemyIterationInfo.Count; i++)
                {
                    //don't remove, but swap. This is how pooling is done in Svelto.
                    //Pooling is not needed when just pure EntityStructs are generated as they are allocation free.
                    //The swap is necessary so that the enemy entity cannot be shot while it's dying
                    //the group works like a sort of state for the Enemy entity in this case.
                    var newID = _entityFunctions.SwapEntityGroup<EnemyEntityDescriptor>(enemyIterationInfo[i].ID,
                                                                                        enemyIterationInfo[i].group);

                    _enemyDeadSequencer.Next(this, EnemyDeathCondition.Death, newID);
                }

                enemyIterationInfo.FastClear();

                yield return null;
            }
        }

        static void SetParametersForDeath(ref EnemyEntityViewStruct enemyEntityViewStruct)
        {
            enemyEntityViewStruct.layerComponent.layer                  = GAME_LAYERS.NOT_SHOOTABLE_MASK;
            enemyEntityViewStruct.movementComponent.navMeshEnabled      = false;
            enemyEntityViewStruct.movementComponent.setCapsuleAsTrigger = true;
        }

        readonly IEntityFunctions    _entityFunctions;
        readonly EnemyDeathSequencer _enemyDeadSequencer;

        struct EnemyIterationInfo
        {
            public readonly EGID ID;

            public EnemyIterationInfo(EGID id, int group)
            {
                ID         = id;
                this.group = group;
            }

            public int group { get; set; }
        }

        struct LambdaParameters
        {
            public EnemyEntityViewStruct[]        item2;
            public FasterList<EnemyIterationInfo> item1;
        }
    }
}
